name: Create Release with Branch Archives

on:
  workflow_dispatch: # Manual trigger

# Add permissions block at the workflow level
permissions:
  contents: write # Required for creating releases and uploading assets
  actions: read # Required for workflow access

jobs:
  create-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup GitHub CLI
        run: |
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y

      - name: Extract version from package.json
        id: version
        run: |
          if [ ! -f package.json ]; then
            echo "Error: package.json not found"
            exit 1
          fi
          version=$(node -p "require('./package.json').version")
          if [ -z "$version" ] || [ "$version" = "undefined" ]; then
            echo "Error: Could not extract version from package.json"
            exit 1
          fi
          echo "version=$version" >> $GITHUB_ENV
          echo "Extracted version: $version"

      - name: Create output directory
        run: |
          mkdir -p "out/${{ env.version }}"
          echo "Created output directory: out/${{ env.version }}"

      - name: Zip branches
        run: |
          # Save the current branch name
          current_branch=$(git rev-parse --abbrev-ref HEAD)
          echo "Current branch: $current_branch"

          # Check for existing .zipignore file
          if [ -f .zipignore ]; then
            echo "Using existing .zipignore file:"
            cat .zipignore
          else
            echo "Creating default .zipignore file..."
            echo ".git/" > .zipignore
            echo ".github/" >> .zipignore
            echo "node_modules/" >> .zipignore
            echo ".next/" >> .zipignore
            echo "out/" >> .zipignore
            echo "temp_zip_dir/" >> .zipignore
            echo "*.log" >> .zipignore
            echo ".env*" >> .zipignore
            echo ".DS_Store" >> .zipignore
            echo "Thumbs.db" >> .zipignore
            echo "Created default .zipignore file"
          fi

          # Function to zip non-gitignored files for a branch
          zip_branch() {
            local branch=$1
            local zip_name="out/${{ env.version }}/${branch}.zip"
            local temp_dir="temp_zip_dir"
            
            echo "Processing branch: $branch"
            
            # Clean temp dir
            rm -rf "$temp_dir"
            mkdir -p "$temp_dir"

            # Checkout branch with error handling
            if ! git checkout "$branch" 2>/dev/null; then
              echo "Warning: Could not checkout branch $branch, skipping..."
              rm -rf "$temp_dir"
              return 1
            fi

            echo "Zipping branch: $branch -> $zip_name"

            # Use rsync to copy files, excluding patterns from .zipignore and .gitignore
            # This ensures .zipignore files are properly respected during the zip process
            local rsync_excludes=""
            if [ -f .zipignore ]; then
              rsync_excludes="$rsync_excludes --exclude-from=.zipignore"
              echo "Applying .zipignore exclusions for branch $branch"
            fi
            if [ -f .gitignore ]; then
              rsync_excludes="$rsync_excludes --exclude-from=.gitignore"
              echo "Applying .gitignore exclusions for branch $branch"
            fi

            if ! rsync -a $rsync_excludes ./ "$temp_dir/"; then
              echo "Error: Failed to copy files for branch $branch"
              rm -rf "$temp_dir"
              return 1
            fi

            # Create zip from temp dir
            if ! (cd "$temp_dir" && zip -qr "../$zip_name" .); then
              echo "Error: Failed to create zip for branch $branch"
              rm -rf "$temp_dir"
              return 1
            fi

            echo "Successfully created: $zip_name"
            
            # Clean up
            rm -rf "$temp_dir"
            return 0
          }

          # Zip current branch
          if ! zip_branch "$current_branch"; then
            echo "Error: Failed to zip current branch"
            exit 1
          fi

          # Get all origin branches except the current one, HEAD, and origin
          branches=$(git for-each-ref --format='%(refname:short)' refs/remotes/origin/ | sed 's/origin\///' | grep -v "^$current_branch$" | grep -v "^HEAD$" | grep -v "^origin$")

          echo "Found additional branches: $branches"

          # Iterate over origin branches
          failed_branches=""
          for branch in $branches; do
            if ! zip_branch "$branch"; then
              failed_branches="$failed_branches $branch"
            fi
          done

          # Return to the original branch
          git checkout "$current_branch"
          echo "Returned to original branch: $current_branch"

          # Report any failed branches
          if [ -n "$failed_branches" ]; then
            echo "Warning: Failed to process branches:$failed_branches"
          fi

      - name: Verify zip files
        run: |
          echo "Created zip files:"
          ls -la "out/${{ env.version }}/"

          # Check if we have at least one zip file
          if [ ! "$(ls -A "out/${{ env.version }}/"*.zip 2>/dev/null)" ]; then
            echo "Error: No zip files were created"
            exit 1
          fi

      - name: Create Release
        run: |
          echo "Creating release v${{ env.version }}"
          gh release create "v${{ env.version }}" \
            --title "v${{ env.version }}" \
            --notes "Release with branch archives" \
            --draft=false \
            --prerelease=false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload Release Assets
        run: |
          echo "Uploading release assets..."
          for zip_file in out/${{ env.version }}/*.zip; do
            if [ -f "$zip_file" ]; then
              echo "Uploading $zip_file"
              if ! gh release upload v${{ env.version }} "$zip_file" --clobber; then
                echo "Error: Failed to upload $zip_file"
                exit 1
              fi
              echo "Successfully uploaded $zip_file"
            fi
          done
          echo "All assets uploaded successfully"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup
        if: always()
        run: |
          echo "Cleaning up temporary files..."
          rm -rf "out/${{ env.version }}"
          rm -rf temp_zip_dir
          echo "Cleanup completed"
